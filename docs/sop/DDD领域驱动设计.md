---
title: DDD领域驱动设计
tags:
  - ABP
  - C#
categories:
  - [DDD]
date: 2024-07-14T20:47:41.000Z
updated: 2024-10-14T13:55:12.726Z
comments: false

---

<!--more-->
# DDD领域驱动设计

//图

主要以ABP为主

## Infrastructure（基础设施层）Domain.Shared


## Domain（领域层）Domain


### 值对象 ValueObject

值对象 = 属性/字段 + 约束

值对象相等：属性/字段全部一样

值对象可以是内置类型，值对象类型，实体类型，聚合根类型

#### 为什么不简单使用一些基础类型？

因为可以根据实际的值对象的含义，设计约束。

例如，温度可以是简单的int类型，但是这样定义会因为int本身的特性（可以为-2^32），不满足温度的特性（必须为绝对零度之上，大于-273.15摄氏度）。

#### 什么时候需要值对象？

实体中的属性/字段必须为值对象

#### 内置对象，创建值对象如何选择？

根据实际值对象含义来选择，当值对象为简单的字符串时，那么内置类型string即为值对象（相当于语言帮你创建了一个值对象，不用自己创建了。如果语言只提供了char，那么需要自己创建一个string类型）

### 实体 Entity

实体 = 唯一标识 + 业务数据 + 业务规则（字符串长度限制，性别限制等）

实体的字段必须是值对象。

实体相等：仅唯一标识相等即可

>+ 注意：实体不应该有持久化的代码，应交给仓储。
>+ 唯一标识创建后就不允许修改。
>+ ABP没有实体对象，只有聚合根。AggregateRoot继承自Entity，其实是把单个实体也当聚合根。（仅有根而已，没有树枝）
 
### 聚合根/聚合对象  AggregateRoot

聚合根 = 一个实体/聚合根 + 一些实体/聚合根 + 业务逻辑 + 数据有效性验证

聚合根用来：

1. 组合对象
2. 隐藏信息
3. 封装业务规则
4. 维护边界一致性

聚合根继承自实体，自然要有实体的限制。

>ABP的聚合对象仅设计聚合对象不涉及实体，完全可以忘记实体的概念只使用聚合根。
>聚合对象的CRUD应由仓储进行。

#### 怎么设计聚合根？

根据实际的业务场景，将经常一起出现的实体聚合，一般涉及2-3个实体/聚合根即可。

对于涉及更多聚合根的业务逻辑，应包装成领域服务，不应在单独一个聚合根里面实现。

>注意：设计聚合根的时候注意相互之间的依赖，防止出现循环依赖（环）
>聚合对象的CRUD应由仓储进行。
>注意多个聚合对象的一致性（事务性ACID）

### 仓储 Repository

负责追踪实体的对象状态，以及负责与数据库的交互和数据持久化。

### 领域服务 DomainService

对于那些不适合放到单个聚合对象的领域逻辑，同时又涉及多个聚合对象的业务逻辑，应实现为领域服务。

### 领域事件 DomainEvent


## 应用层

应用层应是简单的，很薄的一层，只依赖于领域层。


## ABP

ABP仅需看见聚合根，聚合根之间的业务   逻辑由DomainService实现