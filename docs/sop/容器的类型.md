---
title: 容器的类型
tags: []
categories:
  - [未分类]
date: 2023-04-04T00:49:29.000Z
updated: 2024-10-14T13:56:21.188Z
comments: false

---

<!--more-->
# 容器的类型

## 一般容器的特征

X 表示容器类型，如vector<int>; T 表示存储在容器中的对象类型； a 和b 表示类型为X 的值； r 表示类型为X＆的值； u 表示类型为X的标识符

（即如果X 表示vector<int>， 则u 是一个vector<int>对象）。

| 表达式        | 返回类型          | 说明                                                         | 复杂度   |
| ------------- | ----------------- | ------------------------------------------------------------ | -------- |
| X::iterator   | 指向T的选代器类型 | 满足正向选代器要求的任何达代器                               | 编译时间 |
| X::value_type | T                 | T的类型                                                      | 编译时间 |
| X u;          |                   | 创建一个名为u的空容器                                        | 固定     |
| X();          |                   | 创建一个匿名的空容器                                         | 固定     |
| X u(a);       |                   | 调用复制构造函数后u == a                                     | 线性     |
| X u=a;        |                   | 作用同X u(a)                                                 | 线性     |
| r=a;          | X&                | 调用赋值运算符后r == a                                       | 线性     |
| (&a) -> ~X()  | void              | 对容器中每个元素应用析构函数                                 | 线性     |
| a.begin()     | 选代器            | 返回指向容器第一个元素的选代器                               | 固定     |
| a.end()       | 选代器            | 返回超尾值达代器                                             | 固定     |
| a.size()      | 无符号整型        | 返回元素个数,等价于a.end()-a.begin()                         | 固定     |
| a.swap(b)     | void              | 交换a和b的内容                                               | 固定     |
| a==b;         | 可转换为bool      | 如果a和b的长度相同且a中每个元素都等于(==为真)b中相应的元素,则为真 | 线性     |
| a!=b;         | 可转换为bool      | 返回!(a==b)                                                  | 线性     |
| X u(rv);      |                   | 调用移动构造函数后，u与rv的原始值相同                        | 线性     |
| X u = rv;     |                   | 作用同X u(rv)                                                |          |
| a = rv;       | X&                | 调用移动赋值运算符后， u的值与rv的原始值相同                 | 线性     |
| a.cbegin()    | const_iterator    | 返回指向容器第一个元素的const迭代器                          | 固定     |
| a.cend()      | const_iterator    | 返回超尾值const迭代器                                        | 固定     |

# 序列

序列的要求

![2020-09-10_210444](E:\markdown\图床\2020-09-10_210444.png)

序列的可选要求

![2020-09-10_210454](E:\markdown\图床\2020-09-10_210454.png)

# 容器

## vector
前面介绍了多个使用vector 模板的例子，该模板是在vector头文件中声明的。简单地说，vector 是数组的一种类表示， 它提供了自动内

存管理功能，可以动态地改变vector 对象的长度，并随着元素的添加和删除而增大和缩小。它提供了对元素的随机访问。在尾部添加和删

除元素的时间是固定的， 但在头部或中间插入和删除元素的复杂度为线性时间。除序列外，vector 还是可反转容器(reversiblecontainer)

概念的模型。这增加了两个类方法： rbegin( ）和rend( ）， 前者返回一个指向反转序列的第一个元素的迭代器， 后者返回反转序列的超

尾迭代器。因此，如果dice 是一个vector<int>容器，而Show(int)是显示一个整数的函数， 则下面的代码将首先正向显示dice 的内容然

后反向显示

## deque

deque 模板类（在deque 头文件中声明）表示双端队列(double-ended queue)， 通常被简称为deque。在STL 中，其实现类似千vector 

容器，支持随机访问。主要区别在于，从deque 对象的开始位置插入和删除元素的时间是固定的， 而不像vector 中那样是线性时间的。

所以，如果多数操作发生在序列的起始和结尾处， 则应考虑使用deque 数据结构。为实现在deque 两端执行插入和删除操作的时间为固

定的这一目的， deque 对象的设计比vector 对象更为复杂。因此， 尽管二者都提供对元素的随机访问和在序列中部执行线性时间的插入

和删除操作， 但vector 容器执行这些操作时速度要快些。

## list

list 模板类（在list 头文件中声明）表示双向链表。除了第一个和最后一个元素外，每个元素都与前后的元素相链接， 这意味着可以双向

遍历链表。list 和vector 之间关键的区别在千，list 在链表中任一位置进行插入和删除的时间都是固定的(vector 模板提供了除结尾处外的

线性时间的插入和删除，在结尾处，它提供了固定时间的插入和删除）。因此， vector 强调的是通过随机访问进行快速访问， 而list 强

调的是元素的快速插入和删除。与vector 相似，list 也是可反转容器。与vector 不同的是，list 不支持数组表示法和随机访问。与矢量迭

代器不同，从容器中插入或删除元素之后，链表迭代器指向元素将不变。我们来解释一下这句话。例如，假设有一个指向vector 容器第5 

个元素的迭代器，并在容器的起始处插入一个元素。此时， 必须移动其他所有元素， 以便腾出位置， 因此插入后， 第5 个元素包含的值

将是以前第4 个元素的值。因此，迭代器指向的位置不变， 但数据不同。然后， 在链表中插入新元素并不会移动已有的元素， 而只是修

改链接信息。指向某个元素的迭代器仍然指向该元素， 但它链接的元素可能与以前不同。

![2020-09-10_212535](E:\markdown\图床\2020-09-10_212535.png)

## list工具箱

list方法组成了一个方便的工具箱。例如， 假设有两个邮件列表要整理，则可以对每个列表进行排序，合并它们， 然后使用unique(）来

删除重复的元素。sort( ）、merge( ）和unique( ） 方法还各自拥有接受另一个参数的版本， 该参数用千指定用来比较元素的函数。同

样， remove(）方法也有一个接受另一个参数的版本， 该参数用于指定用来确定是否删除元素的函数。这些参数都是谓词函数，将稍后

介绍。

## forward_ list (C++11)

C++ll新增了容器类forward_list,它实现了单链表。在这种链表中，每个节点都只链接到下一个节点，而没有链接到前一个节点。因此

forward—list 只需要正向迭代器， 而不需要双向迭代器。因此，不同千vector和list, forward _list是不可反转的容器。相比千list, forward_ 

list 更简单、更紧凑， 但功能也更少。

## queue

queue模板类（在头文件queue（以前为queue.h) 中声明） 是一个适配器类。由前所述，ostream _iterator模板就是一个适配器，让输

出流能够使用迭代器接口。同样， queue模板让底层类（默认为deque)展示典型的队列接口。queue 模板的限制比deque 更多。它不仅

不允许随机访问队列元素， 甚至不允许遍历队列。它把使用限制在定义队列的基本操作上，可以将元素添加到队尾、从队首删除元素、

查看队首和队尾的值、检查元素数目和测试队列是否为空。表16.10列出了这些操作。注意， pop( ）是一个删除数据的方法， 而不是检

索数据的方法。如果要使用队列中的值， 应首先使用front(）来检索这个值， 然后使用pop(）将它从队列中删除。

![queue操作](E:\markdown\图床\queue操作.png)

## priority_ queue

priority_ queue模板类（在queue 头文件中声明） 是另一个适配器类，它支持的操作与queue相同。两者之间的主要区别在于，在priority_queue中，最大的元素被移到队首（生活不总是公平的， 队列也一样）。内部区别在于，默认的底层类是vector。可以修改用于确定哪个元素放到队首的比较方式，方法是提供一个可选的构造函数参数：

```c++
priority_queue<int> pql; // default version
priority_queue<int> pq2(greater<int>}; // use greater<in巨to order
```

greater<＞(）函数是一个预定义的函数对象， 本章稍后将讨论它。

## stack

与queue相似， stack（在头文件stack 以前为stack.h——中声明）也是一个适配器类，它给底层类（默认情况下为vector)提供了典型的

栈接口。stack 模板的限制比vector更多。它不仅不允许随机访问栈元素，甚至不允许遍历栈。它把使用限制在定义栈的基本操作上， 即

可以将压入推到栈顶、从栈顶弹出元素、查看栈顶的值、检查元素数目和测试栈是否为空。表16.11列出了这些操作。

![stack的操作](E:\markdown\图床\stack的操作.png)

与queue相似， 如果要使用栈中的值， 必须首先使用top(）来检索这个值， 然后使用pop(）将它从栈中删除。

## array

第4章介绍过，模板类array是否头文件array中定义的，它并非STL容器， 因为其长度是固定的。因此，array没有定义调整容器大小的操

作，如push_back(）和insert(），但定义了对它来说有意义的成员函数，如operator D(）和at(）。可将很多标准STL算法用千array对

象， 如copy(）和for_each(）。

# 关联容器

关联容器是将值和键关联

`set  multiset  map multimap`

前两种在set头文件，后两种在map