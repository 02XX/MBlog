---
title: 运算符重载
tags: []
categories:
  - [未分类]
date: 2023-04-04T00:49:29.000Z
updated: 2024-10-14T13:56:58.463Z
comments: false

---

<!--more-->
# 运算符重载

使用`operator +()`重载+运算符，`使用operator *()`重载*运算符，但是不能使用c++没有的符号例如@

## 注意事项

1. 重载后的运算符必须至少有一个操作数是用户定义的类型， 这将防止用户为标准类型重载运算符。
   因此， 不能将减法运算符（－ ）重载为计算两个double值的和， 而不是它们的差。虽然这种限制将对创造
   性有所影响， 但可以确保程序正常运行。
2. 使用运算符时不能违反运算符原来的句法规则。例如， 不能将求模运算符（％）重载成使用一个操
   作数：
3. ```c++
   int x;
   Time shiva;
   % x; // invalid for modulus operator
   % shiva; // invalid for overloaded operator
   ```
   
   同样， 不能修改运算符的优先级。因此， 如果将加号运算符重载成将两个类相加， 则新的运算符与原
   来的加号具有相同的优先级。
4.  不能创建新运算符。例如， 不能定义`operator**()`函数来表示求幕。
5. 不能重载下面的运算符。
  + `size of`: `sizeof`运算符。
  + ` .`： 成员运算符。
  + `.*`： 成员指针运算符。
  + ` ::`： 作用域解析运算符。
  + ` ?:`： 条件运算符。
  + `typeid`: 一个RTTI运算符。
  + `const_cast`: 强制类型转换运算符。
  + `dynamic_cast`: 强制类型转换运算符。
  + `reinterpret_ cast`: 强制类型转换运算符。
  + `static_cast`: 强制类型转换运算符。

6. 可以重载的运算符

|  +   |  -   |  *   |   /    |   %    |    ^     |
| :--: | :--: | :--: | :----: | :----: | :------: |
|  &   |  \|  |  ~=  |   !    |   =    |    <     |
|  >   |  +=  |  -=  |   *=   |   /=   |    %=    |
|  ^=  |  &=  | \|=  |   <<   |   >>   |   >>=    |
| <<=  |  ==  |  !=  |   <=   |   >=   |    &&    |
| \|\| |  ++  |  --  |   ,    |  ->*   |    ->    |
|  ()  |  []  | new  | delete | new [] | delete[] |

**运算符左边是调用对象**