---
title: 素数筛
tags:
  - C++
  - algorithm
categories:
  - [C++]
date: 2023-03-14T23:49:36.000Z
updated: 2024-10-14T13:56:52.194Z
comments: false

---
如何统计`[2,n]`之间的素数，下面给出几种算法。
<!--more-->
## 枚举

>素数判别的基本方法: 如果一个数是合数，那么他必然有一个因子小于 $\sqrt {n}$ 。证明：假设 $n$ 的一个因数 $x>\sqrt{n}$ 那么 $\frac{n}{x} < \sqrt{n}$ ，而 $\frac{n}{x}$ 也是 $n$ 的一个因数。所以如果 $n$ 有一个因数大于 $\sqrt {n}$ 那么他一定有一个因数小于 $\sqrt {n}$ 。

即从 $[2,\sqrt{n}]$ 测试逐个测试。

### 代码

```C++
class Solution {
public:
    bool isPrime(int x) {
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }

    int countPrimes(int n) {
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            ans += isPrime(i);
        }
        return ans;
    }
};
```

+ 时间复杂度 $O(n\log{\sqrt{n}})$
+ 空间复杂度 $O(1)$

## 埃拉托斯尼斯筛法（埃氏筛）

枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。

我们考虑这样一个事实：如果 $x$ 是质数，那么大于 $x$ 的 $x$ 的倍数 $2x,3x,…$ 一定不是质数，因此我们可以从这里入手。

我们设`isPrime[i]` 表示数 `i` 是不是质数，如果是质数则为`1`，否则为`0`。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即`0`，这样在运行结束的时候我们即能知道质数的个数。

这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 $x$ 时，倘若它是合数，则它一定是某个小于 $x$ 的质数 $y$ 的整数倍，故根据此方法的步骤，我们在遍历到 $y$ 时，就一定会在此时将 $x$ 标记为 `isPrime[x]=0`。因此，这种方法也不会将合数标记为质数。

当然这里还可以继续优化，对于一个质数 $x$，如果按上文说的我们从 $2x$ 开始标记其实是冗余的，应该直接**从 $x$开始标记**，因为 $2x,3x,...$ 这些数一定在 $x$ 之前就被其他数的倍数标记过了，例如 2的所有倍数，3的所有倍数等。

<center><img src="素数筛\埃氏筛.gif"></center>

### 代码

```C++
class Solution {
public:
    int countPrimes(int n) {
        vector<int> isPrime(n, 1);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i]) {
                ans += 1;
                if ((long long)i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = 0;
                    }
                }
            }
        }
        return ans;
    }
};
```

+ 时间复杂度：$O(n\log{\log{n}})$
+ 空间复杂度：$O(n)$

## 线性筛（快速素数筛法/欧拉筛）
的时间复杂度是比线性的 $O(logn)$大的，是因为 重复标记了一些合数 。

例如，在使用筛子 $3$ 进行合数标记的时候，数字 $12$ 会被重复标记，因为它已经被 $2$ 标记过一次

快速筛的思路是，让每个合数只被它最小的素因数筛掉 。

快速筛的实施步骤，稍不同于埃氏筛：

1. 和埃氏筛一样，准备相同的一张表格，从中筛去合数。

    初始化，仍然所有方格标记为真，即认为表格中所有数字都是素数。

    不同点是，同时准备一个数组，记录已经找到的素数。

2. 遍历表格中的数字，对于 $2$ ，当前表格中的标记是真，说明是一个素数 。把 $2$ 加入素数数组，筛去 $2×2=4$。
3. 对于 $3$ ，当前表格中的标记是真，说明是一个素数 。
把 $3$ 加入素数数组，筛去 $2×3=6$ 、$3×3=9$
上面的过程，是对当前遍历的数字 $3$ ，乘上已知的每一个素数 $p$，对 $pk$ 进行筛除。

4. 对于 $4$ ，当前表格中的标记是假，说明是一个合数。
筛去$2×4=8$
但是由于 $4$ 是 $2$ 的倍数 ，此时终止筛除，不再筛除 $3×4=12$ ，是因为， 我们希望 $12$ 被它最小的素因数 $2$ 筛除，而不是被素数 $3$ 筛除。
5. 重复上述过程

### 代码

```C++
待补充
```

+ 时间复杂度 $O(\log{n})$
+ 空间复杂度 $O(n)$

>[参考文章](https://leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/)