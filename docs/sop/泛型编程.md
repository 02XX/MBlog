---
title: 泛型编程
tags: []
categories:
  - [未分类]
date: 2023-04-04T00:49:29.000Z
updated: 2024-10-14T13:56:36.028Z
comments: false

---

<!--more-->
# 迭代器

## 前缀后缀++的区分

c++为了区分前缀的++和后缀的++

前缀++ operator++()

后缀++ operator++(int)

## 迭代器的类型

***\*迭代器(iterator)\**** 是一种***\*指针类型\****, 也分***\*const指针本身(地址)\**** 和 ***\*const指针所指的值\****, 两种情况;

但是写法和const内置指针有所不同;

***\*char \* const 相当于 const container<>::iterator\****; 可以修改指针所指的值, 但不能修改指针的地址;

***\*const char \* 相当于 container<>::const_iterator\****; 可以修改指针地址, 但不能修改指针所指的值;

注意代码示例, 两种const和迭代器;

### 输入迭代器

输入迭代器必须能够访问容器中所有的值， 这是通过支持＋＋运算符（前缀格式和后缀格式） 来实现的。如果将输入迭代器设置为指向

容器中的第一个元素， 并不断将其递增， 直到到达超尾位置， 则它将依次指向容器中的每一个元素。顺便说一句， 并不能保证输入迭代

器第二次遍历容器时， 顺序不变。 另 外， 输入迭代器被递增后， 也不能保证其先前的值仍然可以被解除引用。基千输入迭代器的任何

算法都 应当是单通行 (single-pass) 的， 不依赖千前一次遍历时的迭代器值， 也不依赖千本次遍历中前面的迭代器值。

输入迭代器是单项迭代器，可以递增但不可以倒退

### 输出迭代器

STL 使用术语 “ 输出” 来指用于将信息从程序传输给容器的迭代器，因此程序的输出就是容器的输入。

输出迭代器与输入迭代器相似， 只是解除引用让程序能修改容器值， 而不能读取。也许您会感到奇怪， 能够写， 却不能读。发送到显示

器上的输出就是如此， cout 可以修改发送到显示器的字符流， 却不能读取屏幕上的内容。 STL足够通用， 其容器可以表示输出设备， 因

此容器也可能如此。 另外， 如果算法不用读取作容器的内容就可以修改它（如通过生成要存储的新值）， 则没有理由要求它使用能够读

取内容的迭代器。

简而言之， 对千单通行、 只读算法， 可以使用输入迭代器；而对千单通行、 只写算法， 则可以使用输出迭代器。

### 正向迭代器

与输入迭代器和输出迭代器相似，正向迭代器只使用扞运算符来遍历容器，所以它每次沿容器向前移动一 一个元素；然而， 与输入和输

出迭代器不同的是， 它总是按相同的顺序遍历系列值。 另外，将正向迭代器递增后，仍然可以对前面的迭代器值解除引用（如果保存了

它），并可以得到相同的值。这些特征使得多次通行算法成为可能。

正向迭代器既可以使得能够读取和修改数据， 也可以使得只能读取数据

### 双向迭代器

假设算法需要能够双向遍历容器， 情况将如何呢？例如， reverse 函数可以交换第一个个元素和最后 一个元素、将指向第一个元素的指

针加1、将指向第二个元素的指针减一，并重复这一过程，双向迭代器具有正向迭代器的所有特性，同时支持两种递减运算符。

### 随机访问迭代器

有些算法（如标准排序和二分检索）要求能够直接跳到容器中的任何 个元素，这叫做随机访问，需要随机访问迭代器。 随机访问迭代器

具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算） 和用千对元素进行排序的关系运算符。 表16.3列出了

除双向迭代器的操作外，随机访问迭代 器还支持的操作。 其中， X表示随机迭代器类型，T表示被指向的类型，a和b都是迭代器值， n为

整数， r为随机迭代器变量或引用。

| 表达式 | 描述                           |
| ------ | ------------------------------ |
| a+n    | 指向a所指向的元素后的第n个元素 |
| n+a    | 与a+n相同                      |
| a-n    | 指向a所指向的元素前的第n个元素 |
| r += n | 等价千r=r+n                    |
| r -= n | 等价于r=r-n                    |
| a[n]   | 等价千＊（a+n)                 |
| b - a  | 结果为这样的n值， 即b=a+n      |
| a < b  | 如果b - a > 0则为真            |
| a > b  | 如果b < a则为真                |
| a >= b | 如果!(a < b)则为真             |
| a <= b | 如果!(a > b)则为真             |

## 关于`ostream_iterator`迭代器

`ostream_iterator`利用了迭代器的解引用来实现输出

```c++
ostream_iterator<int, char> iter(cout, " ");
*iterator++ = 15; //相当于cout << 15 << " ";
```

## `back_insert_iterator和front_insert_iterator和insert_iterator`

这些迭代器将容器类型作为模板

`back_insert_ iterator `将元素插入到容器尾部， 而 `front_ insert_ iterator `将元素插入到容器的前端。`insert_iterator`将元

素插入到` insert_iterator `构造函数的参数指定的位置前面

```c++
back_insert_iterator<vector<int>> back_iter(dice);
```