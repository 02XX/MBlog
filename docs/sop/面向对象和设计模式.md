---
title: 面向对象和设计模式
tags: []
categories:
  - [未分类]
date: 2023-10-02T16:58:16.000Z
updated: 2024-10-14T13:57:02.591Z
comments: false

---
+ 面向对象
+ 设计模式
<!--more-->
## 1. 面向对象

### 1.1 面向对象的7个设计原则

1. **单一职责原则 (Single Responsibility Principle，SRP):**
   + 一个类应该只有一个引起变化的原因，即一个类应该只有一个责任。

2. **开闭原则 (Open/Closed Principle，OCP):**
   + 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着当需要添加新功能时，最好是通过扩展而不是修改现有代码来实现。

3. **里氏代换原则 (Liskov Substitution Principle，LSP):**
   + 子类型必须能够替换掉它们的基类型，而程序的行为不受影响。这保证了继承关系的正确性。

4. **依赖倒转原则 (Dependency Inversion Principle，DIP):**
   + 高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。这鼓励使用接口和抽象类，而不是具体实现。

5. **接口隔离原则 (Interface Segregation Principle，ISP):**
   + 客户端不应该被迫依赖于它们不使用的接口。一个类不应该被强制实现它用不到的方法，应该将接口拆分成更小的、更具体的接口。

6. **合成复用原则 (Composition/Aggregation Reuse Principle，CARP):**
   + 多用合成（组合）而不是继承来实现代码复用。通过将已有的类组合起来创建新的类，而不是通过继承已有的类。

7. **迪米特原则 (Law of Demeter，LoD):**
   + 一个对象应该对其他对象有最少的了解。一个类对于自己需要知道的类应该知道得越少越好，不和陌生的类直接通信，而是通过它的朋友类进行通信。


### 1.2 七个原则的补充说明

#### 接口隔离原则和单一职责原则的区别

接口隔离原则（Interface Segregation Principle，ISP）和单一职责原则（Single Responsibility Principle，SRP）是面向对象设计中的两个不同的原则，它们有各自独立的关注点。

单一职责原则 (SRP):

+ 定义： 一个类应该只有一个引起变化的原因。换句话说，一个类应该只有一个责任。
+ 目标： 保持类的简单性，可维护性，和可理解性。如果一个类有多个责任，当其中一个责任发生变化时，可能会影响其他责任，导致代码变得复杂和难以维护。
+ 示例： 一个类负责处理用户输入和计算结果，违反了单一职责原则。分割成两个类，一个处理输入，一个负责计算，会更符合原则。
接口隔离原则 (ISP):

+ 定义： 客户端不应该被迫依赖于它们不使用的接口。换句话说，一个类不应该被强制实现它用不到的接口。
+ 目标： 避免类被迫实现一些它们不需要的方法，减少接口的臃肿性。一个类应该只需实现它所需要的方法，而不是强制实现所有可能的方法。
+ 示例： 如果有一个通用的接口，但某个具体类只需要其中的一部分方法，它不应该被强制实现其余的方法。可以通过将接口拆分成更小的接口，每个类只实现它需要的接口。
在实际设计中，这两个原则经常一起使用以创建更灵活、可维护和可扩展的代码。单一职责原则关注于类的内部，确保类具有清晰的责任；而接口隔离原则关注于类与接口之间的关系，确保类不被迫依赖于不需要的接口。

## 2. 设计模式

设计模式分为三种类型，共23种：

|   类型     | 模式                 |
|--------------|----------------------|
| 创建型   | 单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式 |
| 结构型   | 适配器模式、桥接模式、装饰器模式、组合模式、外观模式、享元模式、代理模式 |
| 行为型   | 策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 |

### 创建型

#### 工厂模式 (Factory Pattern)

##### 简单工厂模式 (Simple Factory Pattern)

简单工厂模式中，一个工厂类包含一个方法，根据传入的参数决定创建哪一种产品类的实例。客户端不需要关心对象的创建过程。

##### 工厂方法模式 (Factory Method Pattern)

工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类。这使得一个类的实例化延迟到其子类。

##### 抽象工厂模式 (Abstract Factory Pattern)

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定它们的具体类。它是工厂方法模式的升级版本。

抽象工厂经常以工厂方法的方式实现

#### 单例模式 (Singleton Pattern)

单例模式确保一个类只有一个实例，并提供一个全局访问点。这对于控制资源的共享或限制特定类型的实例数量非常有用。

##### 优点

+ 全局控制：保证只有⼀个实例，这样就可以严格的控制客户怎样访问它以及何时访问它，简单的说就是对唯⼀
+ 实例的受控访问（引⽤⾃《⼤话设计模式》第21章）
+ 节省资源：也正是因为只有⼀个实例存在，就避免多次创建了相同的对象，从⽽节省了系统资源，⽽且多个模
块还可以通过单例实例共享数据。
+ 懒加载：单例模式可以实现懒加载，只有在需要时才进⾏实例化（懒汉式），这⽆疑会提⾼程序的性能

##### 要求

+ 私有的构造函数：防⽌外部代码直接创建类的实例
+ 私有的静态实例变量：保存该类的唯⼀实例
+ 公有的静态⽅法：通过公有的静态⽅法来获取类的实例

##### 应用场景

1. 资源共享
多个模块共享某个资源的时候，可以使⽤单例模式，⽐如说应⽤程序需要⼀个全局的配置管理器来存储和管理配置
信息、亦或是使⽤单例模式管理数据库连接池。
2. 只有⼀个实例
当系统中某个类只需要⼀个实例来协调⾏为的时候，可以考虑使⽤单例模式， ⽐如说管理应⽤程序中的缓存，确保
只有⼀个缓存实例，避免重复的缓存创建和管理，或者使⽤单例模式来创建和管理线程池。
3. 懒加载
如果对象创建本身就⽐较消耗资源，⽽且可能在整个程序中都不⼀定会使⽤，可以使⽤单例模式实现懒加载。
在许多流⾏的⼯具和库中，也都使⽤到了单例设计模式，⽐如Java中的Runtime 类就是⼀个经典的单例，表示程序
的运⾏时环境。此外 Spring 框架中的应⽤上下⽂ ( ApplicationContext ) 也被设计为单例，以提供对应⽤程序中
所有 bean 的集中式访问点。

#### 建造者模式



### 结构型

#### 适配器模式与外观模式 (Adapter Pattern and Facade Pattern)

适配器模式允许接口不兼容的类协同工作，将一个类的接口转换成客户希望的另一个接口。

外观模式提供了一个统一的接口，用于访问子系统中的一群接口。外观定义了一个高层接口，使得子系统更容易使用。

#### 代理模式 (Proxy Pattern)

代理模式提供了一个代理类，控制对其他对象的访问。它通常用于创建访问对象的代理，以便在实际对象上做一些控制。

### 行为型

#### 策略模式 (Strategy Pattern)

策略模式定义了一系列算法，将每个算法封装起来，并使它们可以互相替换。这样，算法的变化不会影响到使用算法的客户端。

#### 观察者模式 (Observer Pattern)

观察者模式定义了对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新。



#### 命令模式 (Command Pattern)

命令模式将请求封装为一个对象，从而使用户能够用不同的请求对客户进行参数化，队列请求和日志请求，并支持可撤销的操作。



#### 迭代器与组合模式 (Iterator Pattern and Composite Pattern)

迭代器模式提供一种方法访问一个容器对象中各个元素，而不需暴露该对象的内部细节。

组合模式允许你将对象组合成树形结构以表示"部分-整体"的层次结构。通过组合对象形成树形结构以表示整体-部分的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

#### 状态模式 (State Pattern)

状态模式允许对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。



### 2.10 复合模式 (Composite Pattern)

复合模式将对象组合成树形结构以表示"部分-整体"的层次结构。这种模式使得客户端对单个对象和组合对象的使用具有一致性。