---
title: c++面试问题
tags:
  - C++
categories:
  - [C++]
date: 2023-03-22T12:06:58.000Z
updated: 2024-10-14T13:55:35.172Z
comments: false

---
列举一些C++面试可能问到的问题
<!--more-->
2023/3/21 20:48:40

面向过程和面向对象的区别

2023/3/21 20:48:54

面向过程是一种编程方法论，它将程序分解为一个个的步骤或者函数，并通过控制这些步骤或函数的顺序和参数来达到程序的目的。而面向对象则是一种更高层次的抽象，通过将数据和相应的操作封装在一起，形成一个对象，从而实现对程序进行建模和设计。面向对象的主要特征包括继承、封装和多态性，能够提高程序的可重用性和可扩展性，同时也能够简化程序的复杂度。总之，面向过程强调流程控制，而面向对象强调数据抽象和封装。

2023/3/21 20:50:07

c和c++区别

2023/3/21 20:50:31

C和C++是两种不同的编程语言，它们之间的主要区别包括：

1. C++是C语言的扩展，与C语言相比具有更多的功能和特性，如类、继承、多态、命名空间等。

2. C++支持面向对象编程（OOP）和泛型编程，而C语言只支持过程式编程。

3. C++在语法上比C语言更加复杂，需要更高的学习门槛。

4. C++中的一些关键字和语法与C语言不同，例如引用、模板和命名空间等。

5. C++支持函数重载和运算符重载，这可以方便地实现多态性，而C语言不支持这些特性。

6. 由于C++中的许多特性需要额外的程序库和工具支持，因此C++程序通常比C程序更大。

总之，C++在C语言的基础上增加了更多的特性和功能，尤其是面向对象编程方面。但是，由于C++的复杂性和体量较大，相比之下，C语言更加简单易学且适用范围更广泛。

2023/3/21 20:51:51

类型和结构的区别

2023/3/21 20:52:07

类型（Type）和结构（Structure）是两个不同的概念。

类型指的是变量或表达式的数据类型，包括整型、浮点型、字符型等。类型定义了变量或表达式所能存储的数据种类和范围，同时也决定了这些数据的操作方式和内存分配情况。

结构指的是将多个不同类型的数据组合在一起形成的一个复合数据类型，也就是所谓的“结构体”。结构体可以包含任意数量的不同类型的数据成员，并且可以根据需要自由地组织和使用这些成员，以便更好地描述和处理复杂的数据关系。

总之，类型是用来描述数据元素本身的性质，而结构则是用来描述多个数据元素之间的关系和组织方式。

2023/3/21 20:54:28

c++存储的五个区

2023/3/21 20:54:50

C++ 程序在运行时使用的内存被分成以下五个区：

1. 代码区（Code Segment）：存放程序的指令代码，通常是只读的，不允许写入或修改。

2. 全局数据区（Global Data Segment）：存放全局变量和静态变量，这些变量在程序启动时就已经分配好了空间，并一直存在于整个程序的生命周期中。

3. 堆区（Heap）：由程序员手动管理，用于动态分配和释放内存。通过new和delete等操作来进行内存的分配和释放。

4. 栈区（Stack）：用于存放函数调用时需要的临时变量、参数和返回地址等信息，由系统自动管理，不需要手动分配和释放。

5. 常量区（Constant Segment）：存放常量数据，如字符串常量等，通常也是只读的，不允许修改。

这些区域的大小和位置取决于编译器和操作系统的具体实现方式。

2023/3/21 20:56:13

c++ static的作用

2023/3/21 20:56:34

C++ 中 static 关键字有多种用法，常见的包括：

1. 静态变量：在函数内部使用 static 关键字声明的变量称为静态变量，它与普通变量的区别在于静态变量只会被初始化一次，在函数调用结束后也不会被销毁，而是一直存在于整个程序的生命周期中。

2. 静态成员变量：在类中使用 static 关键字声明的成员变量称为静态成员变量，它属于整个类而不是某个对象，可以被所有同一类的对象所共享。

3. 静态成员函数：在类中使用 static 关键字声明的成员函数称为静态成员函数，它与普通成员函数的区别在于静态成员函数可以通过类名直接调用，而无需创建对象实例。同时，静态成员函数不能访问非静态成员变量和成员函数，只能访问静态成员变量和成员函数以及全局变量和函数。

总之，static 关键字的作用主要是控制变量、函数或成员的生命周期、作用域和访问方式，使得程序更加灵活和高效。

2023/3/21 20:57:47

c++ extern作用

2023/3/21 20:58:07

C++ 中 extern 关键字主要用于指示函数或变量的声明或定义在其他文件中，以便在当前文件中进行使用。具体来说，extern 有以下两种用法：

1. 声明全局变量或函数：在某个源文件中使用 extern 关键字声明一个全局变量或函数，表示该变量或函数实际上是在另外一个源文件中定义的，编译器会在链接时将其与定义进行匹配。

2. 引用外部全局变量或函数：在某个源文件中使用 extern 关键字引用另一个源文件中定义的全局变量或函数，以便在编译时能够正确地解析依赖关系并生成目标代码。

总之，extern 关键字主要用于在不同源文件之间共享变量和函数，并且需要在其中一个文件中进行声明或定义（通常是定义），以便编译器和链接器能够正确地处理依赖关系。

2023/3/21 21:03:04

什么是类什么是对象

2023/3/21 21:03:28

在面向对象编程中，类（Class）和对象（Object）是两个基本的概念。

类指的是一种数据类型，用于描述具有相同属性和行为的对象集合。类定义了一组公共的特性、方法和操作，可以被多个对象所共享和复用，从而实现对现实世界中某种事物或概念的抽象和建模。

对象则是类的一个实例，它具有类定义的所有属性和行为，并且可以进行各种操作和交互。每个对象都是独立的，有自己的状态和行为，与其他对象之间相互独立。

例如，人类可以看作是一个类，每个具体的人则是该类的一个对象。人类具有共同的属性和行为，如姓名、年龄、性别、说话、走路等，而不同的人具有不同的属性和行为。因此，我们可以通过定义一个人类的类来描述人类的共同点和特征，并创建不同的人类对象来表示不同的人。

总之，类是一种模板或蓝图，用于定义一组共同的属性、行为和操作，而对象则是类的实例，具有这些属性、行为和操作的具体实现和表现。

2023/3/21 21:05:01

构造函数和析构函数的作用

2023/3/21 21:05:39

构造函数和析构函数是 C++ 中用于初始化和清理对象的两种特殊函数。

构造函数（Constructor）是一种特殊的成员函数，用于在创建对象时对其进行初始化。构造函数的名称必须与类名相同，没有返回值类型，可以带有参数，也可以重载多个构造函数。当对象被创建时，程序会自动调用该对象的构造函数来初始化它的各个属性和状态。

析构函数（Destructor）是一种特殊的成员函数，用于在对象被销毁时进行清理操作。析构函数的名称必须是类名前加上“~”，没有返回值类型，不带参数，也不能重载。当对象被销毁时，程序会自动调用该对象的析构函数来释放它所占用的内存资源、关闭文件、释放锁等。

构造函数和析构函数的作用如下：

1. 构造函数用于在对象创建时对其进行初始化，确保对象的属性和状态正确地设置，避免出现未定义或未知的行为。

2. 析构函数用于在对象销毁时进行清理工作，释放对象占用的内存资源和系统资源，避免出现内存泄漏和资源浪费。

3. 构造函数和析构函数都是自动调用的，无需手动调用，从而保证了代码的简洁性和可靠性。

总之，构造函数和析构函数是 C++ 中非常重要的概念，用于确保对象的正确性、可靠性和安全性。

2023/3/21 22:50:26

什么是封装、继承、多态

2023/3/21 22:51:09

封装、继承和多态是面向对象编程的三个基本概念，分别表示了不同的抽象和实现层次。

1. 封装（Encapsulation）：封装是将数据和操作（或方法）组合在一起形成一个独立、完整的单位，并限制外部对其直接访问和修改。通过封装，可以有效地保护数据的安全性和完整性，避免数据被误用或破坏。同时，封装也使得代码更加模块化，易于维护和复用。

2. 继承（Inheritance）：继承是一种从已有类派生出新类的机制，新类会自动获得已有类的全部属性和方法，并可以在此基础上进行修改和扩展。通过继承，可以实现代码的重用和扩展，降低系统的复杂度和开发成本。同时，继承也使得代码更加易于理解和维护，因为它能够体现出类之间的关系和层次结构。

3. 多态（Polymorphism）：多态是指同一操作作用于不同的对象上，会产生不同的结果。多态包括静态多态和动态多态两种形式，其中静态多态是指函数重载和运算符重载等编译期决定的多态，而动态多态是指虚函数和动态绑定等运行期决定的多态。通过多态，可以实现代码的灵活性和扩展性，充分发挥代码的潜力和适应性。

总之，封装、继承和多态是面向对象编程中最基本、最重要、最核心的三个概念，它们共同构成了面向对象编程的思想和特点，能够大大提高代码的可读性、可维护性和可扩展性。

2023/3/21 22:53:28

什么是友元

2023/3/21 22:54:04

C++ 中，友元（Friend）是一种特殊的机制，用于允许某个类或函数访问另一个类的私有成员或保护成员。具体来说，友元是通过在类或函数之间建立非继承关系的访问权限，使得它们能够互相访问对方的私有成员或保护成员。

需要注意的是，友元并不是继承或派生关系，而是一种临时的访问授权机制，从而可以在一定程度上打破访问权限的限制，提供更加灵活和实用的编程方式。同时，使用友元应该慎重，因为它会引入额外的耦合性和风险，并可能破坏封装性和安全性。

友元可以是以下三种类型：

1. 友元函数：在类中声明函数时，可以在前面添加 friend 关键字，将该函数声明为类的友元函数，从而允许它访问类的私有成员和保护成员。

2. 友元类：在类中声明另一个类时，可以在前面添加 friend 关键字，将该类声明为当前类的友元类，从而允许它访问当前类的私有成员和保护成员。

3. 友元成员函数：在类中定义成员函数时，可以在函数定义前面添加 friend 关键字，将该成员函数声明为其他类或函数的友元成员函数，从而允许它访问这些类或函数的私有成员和保护成员。

总之，友元是一种特殊的权限机制，用于允许某些类或函数访问另一些类的私有成员或保护成员，从而提高了程序的灵活性和可用性。但是，在使用友元时需要注意平衡代码的封装性和安全性，并避免滥用和误用。

2023/3/21 22:54:14

为什么不直接将友元声明为成员函数

2023/3/21 22:54:45

虽然在 C++ 中可以将友元函数或类用于访问另一个类的私有成员或保护成员，但为什么不直接将它们声明为该类的成员函数呢？这是因为友元与成员函数之间存在以下两点区别：

1. 作用域不同：友元函数或类不属于目标类的作用域，而是在外部声明和定义的，因此它们能够访问目标类的私有成员或保护成员，但不能直接使用目标类的成员函数和成员变量。相反，成员函数属于目标类本身的作用域，可以直接访问该类的私有成员、保护成员和公共成员。

2. 关系不同：友元并不是继承或派生关系，而是一种临时的授权机制。其作用是允许某个函数或类访问另一个类的私有成员或保护成员，从而提高了代码的灵活性和可用性。相反，成员函数是目标类所拥有的方法，它们被设计为操作该类的成员变量和状态，具有更稳定和持久的关系。

因此，友元通过临时的权限机制实现了对类成员的访问，而成员函数则是类自身的方法，具有更稳定和持久的关系。由于它们的特性和作用不同，我们需要根据实际情况选择合适的方式来访问类的私有成员或保护成员，从而避免滥用和误用。

2023/3/21 23:00:28

ADT是什么

2023/3/21 23:00:59

ADT 的全称是抽象数据类型（Abstract Data Type）。它是一种数学模型，定义了一组数据和对这些数据进行操作的一系列运算，而不涉及具体的实现细节。ADT 是独立于编程语言和具体实现的，可以被看作是一种高层次的抽象概念。

在计算机科学中，ADT 是一种非常重要的概念，它提供了一种通用的方法来描述和设计数据结构，可以使得程序更加模块化、可维护和可扩展。通过 ADT，我们可以将数据和操作分离，从而降低代码的耦合性和复杂度，提高代码的可读性和可靠性。

常见的 ADT 包括栈、队列、链表、二叉树、图等。这些 ADT 同时也是数据结构的基本概念，在实现具体的算法和程序时，需要根据具体需求选择合适的 ADT，并采用相应的实现方式。

总之，ADT 是一种高层次的抽象概念，用于描述和设计数据结构的数据和操作，提高了程序的模块化、可维护性和可扩展性，是计算机科学中非常重要的概念之一。

2023/3/21 23:17:24

c++中explicit是什么

2023/3/21 23:17:55

在 C++ 中，explicit 是一个关键字，用于声明构造函数或转换函数为显式构造函数或显式转换函数。

当一个构造函数被声明为 explicit 时，在调用该构造函数时必须使用直接初始化的方式，即使用括号将参数括起来，否则编译器将会报错。这样可以避免隐式类型转换和意外的行为发生。

例如：

```c++
class Test {
public:
  explicit Test(int x) { ... }
};

int main() {
  Test obj = 10; // 错误，不能调用Test(10)隐式转换成Test对象
  Test obj2(10); // 正确，使用直接初始化调用构造函数
  return 0;
}
```

同样地，当一个转换函数被声明为 explicit 时，它不再能够进行隐式类型转换，只能通过显式类型转换来进行调用。

例如：

```c++
class Test {
public:
  explicit operator int() { ... }
};

int main() {
  Test obj;
  int x = obj; // 错误，不能将obj隐式转换成int类型
  int y = static_cast<int>(obj); // 正确，使用显式类型转换调用转换函数
  return 0;
}
```

通过使用 explicit 关键字，我们能够更加明确地声明构造函数或转换函数的语义，避免隐式类型转换和可能出现的错误和问题。

2023/3/22 11:59:20

c++内存泄漏的情况

2023/3/22 11:59:54

在 C++ 中，内存泄漏（Memory Leak）指的是程序在运行过程中分配的内存空间没有被正确地释放，从而导致系统中出现了一些不可用的内存块。这些内存块会逐渐积累，最终可能导致整个系统崩溃或运行缓慢等问题。

C++ 中内存泄漏的情况包括以下几种：

1. 没有使用 delete 关键字释放 new 动态分配的内存。当使用 new 运算符为对象分配内存时，应当在不需要该对象时使用 delete 运算符手动释放内存。如果没有释放该内存，则可能会导致内存泄漏。

```c++
int* ptr = new int;
// do something with ptr
// ...
delete ptr; // 释放内存
```

2. 在构造函数或析构函数中发生异常而未能释放资源。在 C++ 中，当对象抛出异常时，程序会自动调用析构函数来清理内存和资源。如果在析构函数中发生异常，则可能导致部分资源无法被正确地释放，从而引发内存泄漏。

```c++
class Test {
public:
  Test() {
    ptr = new int;
    // 可能发生异常
    throw std::runtime_error("error");
  }
  ~Test() {
    // 发生异常时未释放内存
    delete ptr;
  }
private:
  int* ptr;
};
```

3. 指针使用错误导致内存泄漏。在 C++ 中，使用指针时必须小心谨慎，避免出现指针悬挂、指针越界、重复释放等问题，否则可能导致内存泄漏。

```c++
int* ptr = new int[10];
ptr++; // 导致原始指针丢失，无法释放
delete[] ptr;

int* ptr2 = new int;
delete[] ptr2; // 错误，使用 delete[] 释放单个对象会导致未定义行为
```

总之，内存泄漏是 C++ 程序中常见的问题之一，需要小心处理以确保程序的稳定性和安全性。遵循内存管理的良好实践，例如使用智能指针、RAII 等技术，可以有效地预防和修复内存泄漏问题。

2023/3/22 12:10:19

c++源程序执行过程中，有哪些步骤

2023/3/22 12:10:30

通常情况下，C++源程序的执行过程可以概括为以下几个步骤：

1. 预处理：对源代码进行宏展开、头文件包含等预处理操作，生成预处理后的代码。
2. 编译：将预处理后的代码翻译成汇编语言或机器语言的目标文件。
3. 链接：将编译生成的目标文件与库文件进行链接，生成可执行文件。
4. 加载：将可执行文件加载到内存中，操作系统为其分配运行所需的资源。
5. 执行：CPU按照指令集执行加载到内存中的可执行文件，完成程序的执行。

需要注意的是，这是一个简化的执行过程，实际上还有很多细节和特殊情况需要考虑，例如优化、调试等。